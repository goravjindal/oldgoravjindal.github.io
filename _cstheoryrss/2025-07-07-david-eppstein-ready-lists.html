<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>David Eppstein: Ready lists | Gorav  Jindal</title>
    <meta name="author" content="Gorav  Jindal">
    <meta name="description" content="Gorav Jindal's personal and academic webpage
">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://goravjindal.github.io/_cstheoryrss/2025-07-07-david-eppstein-ready-lists.html">

    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
    
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Gorav </span>Jindal</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">About</a>
              </li>
              

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/cv/">CV</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/publications/">Publications</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/teaching/">Teaching</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/cstheoryrss/">CS Theory RSS</a>
              </li>

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="container mt-5">
      
        <!-- _layouts/post.html -->

<div class="post">

  <header class="post-header">
    <h1 class="post-title">David Eppstein: Ready lists</h1>
    <p class="post-meta">July 7, 2025</p>
    <p class="post-tags">
      <a href="/blog/2025"> <i class="fas fa-calendar fa-sm"></i> 2025 </a>

    </p>
  </header>

  <article class="post-content">
    
    <div id="markdown-content">
      <p>Beginning computer science students learn about stacks, queues, and priority queues, different ways of organizing and ordering a collection of tasks to be performed. But more basic than any of those, and less frequently taught and formalized, is the <em>ready list</em>, a collection of tasks to be performed whose ordering is not important. All it needs to do is to allow new tasks to be added to the collection and to find and remove an arbitrary task from the collection.</p>

<p>Standard algorithms that work with ready lists include:</p>

<dl>
  <dt>Reachability</dt>
  <dd>Input: a directed or undirected graph and a starting vertex in the graph</dd>
  <dd>Output: the set of vertices that can be reached from the starting vertex</dd>
  <dd>Algorithm:

    <ul>
      <li>Initialize a set of reachable vertices, and a ready list of reachable but unprocessed vertices, both initially containing only the starting vertex.</li>
      <li>While the ready list is non-empty:
        <ul>
          <li>Find and remove a vertex (v) from the ready list</li>
          <li>For each outgoing neighbor (w) of (v) that is not already in the reachable set, add (w) to both the reachable set and the ready list.</li>
        </ul>
      </li>
      <li>Return the reachable set</li>
    </ul>
  </dd>
  <dt>Topological ordering</dt>
  <dd>Input: a directed acyclic graph</dd>
  <dd>Output: a sequence of vertices, ordered so all edges go from earlier to later in the ordering</dd>
  <dd>Algorithm:

    <ul>
      <li>Initialize a ready list of vertices with no incoming edges</li>
      <li>While the ready list is non-empty:
        <ul>
          <li>Find and remove a vertex (v) from the ready list</li>
          <li>Delete (v) from the graph and output (v)</li>
          <li>Add to the ready list any former neighbor of (v) which, after the deletion, has no more incoming edges</li>
        </ul>
      </li>
    </ul>
  </dd>
  <dt>Stable matching</dt>
  <dd>Input: A set of job applicants and a set of employers, with each applicant having a preference ordering among the employers and each employer having a preference ordering among the applicants</dd>
  <dd>Output: A stable matching</dd>
  <dd>Algorithm:

    <ul>
      <li>Initialize a ready list of job offers from each employer to its top applicant</li>
      <li>While the ready list is non-empty:
        <ul>
          <li>Find and remove an offer from employer (X) to applicant (A)</li>
          <li>If (A) prefers their current situation over (X), add to the ready list a new job offer from (X) to (X)’s next applicant.</li>
          <li>Otherwise, match (A) and (X); if (A) was previously matched, remove that match and add to the ready list a new job offer from (A)’s previous employer to its next applicant</li>
        </ul>
      </li>
    </ul>
  </dd>
</dl>

<p>In the cases of reachability and stable matching, the ordering chosen by the ready list is unimportant: you will always get the same reachable set and the same matching. In the case of topological ordering, you may get different orderings but regardless of order you will always output the same set of vertices for any given graph, even if the graph is not acyclic.</p>

<p>This invariance is usually proven algorithm-by-algorithm, but it is true very generally for a class of algorithms with three simple properties: First, an item that is added to the ready list stays there until it is processed. Second, each item is added to the ready list only once. And third, the condition for adding an item to the ready list should be a monotonic combination of which other items have already been processed: if a certain combination of processed items triggers an addition, then any superset of the same combination should trigger the same addition. The trigger for reachability is that some neighbor is processed, and the trigger for topological ordering is that all incoming neighbors are processed. For stable matching, the trigger for an offer from (X) to (A) is that (X)’s previous applicant has already received both an offer from (X) and an offer from another employer that they prefer over (X).</p>

<p>These three properties are enough to prove that the sequences in which items can be processed by an algorithm of this type form an <a href="https://en.wikipedia.org/wiki/Antimatroid" rel="external nofollow noopener" target="_blank">antimatroid</a>. The key axiom of antimatroid sequences that we need to prove is that, if two sequences (S) and (T) can both be generated, and (S) contains an item not in (T), then (S) contains an item (x) that can be processed next after (T), producing a sequence (Tx). To prove this, simply let (x) be the first item that belongs to (S) but not (T), and apply the monotonic trigger property.</p>

<p>In any antimatroid, all sequences that cannot be extended consist of the same set of items. Again, this is easy to prove: if two sequences had different sets of items, then one would contain an item by which the other could be extended. To translate this into terms more familiar to the beginning computer science students: if a ready list obeys the three properties given above, and we run an algorithm using it until the ready list becomes empty, then all runs of the algorithm process the same set of items.</p>

<p>While exploring this I ran into another basic algorithm that in its usual form is based on integer priority queues but can be transformed into a ready list algorithm:</p>

<dl>
  <dt>Degeneracy</dt>
  <dd>Input: An undirected graph</dd>
  <dd>Output: A subgraph whose minimum degree is as large as possible</dd>
  <dd>Algorithm:

    <ul>
      <li>Initialize an empty ready list</li>
      <li>While the graph is non-empty:
        <ul>
          <li>If the ready list is empty, set (d) to the minimum degree in the graph, set (S) to be an empty set, and add to the ready list all vertices of degree (d)</li>
          <li>Find and remove a vertex (v) from the ready list</li>
          <li>Delete (v) from the graph and add (v) to (S)</li>
          <li>Add to the ready list any former neighbors of (v) for which this removal decreases the degree to (\le d)</li>
        </ul>
      </li>
      <li>Output the subgraph induced in the original input graph by (S)</li>
    </ul>
  </dd>
</dl>

<p>This can be made to run in linear time but the details of that are beyond the scope of this post. Proving monotonicity of the condition for triggering addition to the ready list is a little less obvious here. For each integer (k) we can define a subgraph called the (k)-core, the union of all subgraphs whose minimum degree is at least (k). The output is the (d)-core. The monotonic trigger for any vertex (v) to be added to the ready list is that all vertices not in the (k)-core have already been processed, where (k) is the largest value for which the (k)-core contains (v), and that (v) has at most (k) unprocessed neighbors.</p>

<p>Abstractly, the decreasing degrees of the vertices can be seen as a kind of element quality that decreases as other elements are removed; we seek the subset maximizing the minimum quality of any of its elements. My latest preprint, “Decremental greedy polygons and polyhedra without sharp angles” (<a href="https://arxiv.org/abs/2507.04538" rel="external nofollow noopener" target="_blank">arXiv:2507.04538</a>, to appear at this year’s Canadian Conference on Computational Geometry) looks at a general class of problems like this, and identifies several more. One of the simplest of these is to find a polygon through a subset of the points that maximizes the minimum interior angle.</p>

<p><img src="https://11011110.github.io/blog/assets/2025/maxmin-angle.svg" alt="A set of points spaced roughly evenly on four crossing circles, and its max-min angle polygon, the 24 points on one of the circles"></p>

<p>So here is the algorithm; I think the similarities between this and the degeneracy algorithms are obvious.</p>

<dl>
  <dt>Max-min angle polygon</dt>
  <dd>Input: A set of points in (\mathbb{R}^2)</dd>
  <dd>Output: A polygon with the points as vertices whose sharpest angle is as large as possible</dd>
  <dd>Algorithm:

    <ul>
      <li>Initialize an empty ready list</li>
      <li>While the set of points is non-empty:
        <ul>
          <li>If the ready list is empty, set (\theta) to the minimum angle of a convex hull vertex of the remaining points, set (S) to be an empty set, and add to the ready list all convex hull vertices of angle (\theta)</li>
          <li>Find and remove a point (p) from the ready list</li>
          <li>Delete (p) from the points and add (p) to (S)</li>
          <li>Add to the ready list any convex hull vertices for which this removal decreases the angle to (\le\theta)</li>
        </ul>
      </li>
      <li>Output the convex hull of (S)</li>
    </ul>
  </dd>
</dl>

<p>This can be made to run in time (O(n\log n)); for details see the preprint. I’ll finish with one more from the full version of the paper, on cycles in directed graphs.</p>

<dl>
  <dt>Bottleneck cycle</dt>
  <dd>Input: A directed graph with weighted edges</dd>
  <dd>Output: A cycle whose minimum edge weight is as large as possible</dd>
  <dd>Algorithm:

    <ul>
      <li>Initialize a ready list of the edges out of all vertices that have no incoming edges, and the edges into all vertices that have no outgoing edges</li>
      <li>Initialize an empty set (S)</li>
      <li>While the set of graph edges is non-empty:
        <ul>
          <li>If the ready list is empty, set (w) to the minimum weight of a remaining edge, set (S) to be an empty set, and add to the ready list all edges of weight (w)</li>
          <li>Find and remove an edge ((u,v)) from the ready list</li>
          <li>Delete edge ((u,v)) from the graph and add it to (S)</li>
          <li>If (u) has no more outgoing edges, add to the ready list all its incoming edges.</li>
          <li>If (v) has no more incoming edges, add to the ready list all its outgoing edges.</li>
        </ul>
      </li>
      <li>Find and output any cycle in the subgraph of edges in (S)</li>
    </ul>
  </dd>
</dl>

<p>For this one, a direct implementation on a graph with (n) vertices and (m) edges would take time (O(m\log n)), not really better than the obvious binary search. However, it can be made to run in linear time for graphs with edges already sorted by length, and this presorted version can be used as a subroutine in a different algorithm for graphs with unsorted edges, in time (O(m\log^* n)). In turn, bottleneck cycles can be used as a subroutine in an algorithm for finding the max-min angle closed polygonal curve for 3d points, allowing the curve to pass repeatedly through points and segments, in time (O(n^3\log^* n)). For details see the preprint.</p>

<p>(<a href="https://mathstodon.xyz/@11011110/114815823766596754" rel="external nofollow noopener" target="_blank">Discuss on Mastodon</a>)</p>

<p>By David Eppstein</p>

<p><a href="https://11011110.github.io/blog/2025/07/07/ready-lists.html" rel="external nofollow noopener" target="_blank">Read original post</a></p>

    </div>
  </article>


</div>

      
    </div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2025 Gorav  Jindal. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>.

      </div>
    </footer>

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
    
  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/zoom.js"></script>

  <!-- Bootstrap Table -->
  <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.3/dist/bootstrap-table.min.css">
  <script defer src="https://unpkg.com/bootstrap-table@1.21.3/dist/bootstrap-table.min.js"></script>

  <!-- Load Common JS -->
  <script src="/assets/js/no_defer.js"></script>
  <script defer src="/assets/js/common.js"></script>
  <script defer src="/assets/js/copy_code.js" type="text/javascript"></script>

    
  <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
  <script async src="https://badge.dimensions.ai/badge.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  </body>
</html>
